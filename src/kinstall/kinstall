#!/usr/bin/env python3

# ██╗  ██╗██████╗  ██████╗ ███████╗
# ██║ ██╔╝██╔══██╗██╔═══██╗██╔════╝
# █████╔╝ ██║  ██║██║   ██║███████╗
# ██╔═██╗ ██║  ██║██║   ██║╚════██║
# ██║  ██╗██████╔╝╚██████╔╝███████║
# ╚═╝  ╚═╝╚═════╝  ╚═════╝ ╚══════╝
# ---------------------------------
#    KDOS Installer
# ---------------------------------

import curses
import curses.textpad
import sys
import os
import time
import subprocess
import threading
import queue
import re
import shutil
import math
import traceback

# --- Configuration ---
VERSION = "3.0"
MOUNT_POINT = "/mnt"

# --- Colors & Styles ---
CP_BASE = 1
CP_HL   = 2
CP_ACCENT = 3
CP_WARN = 4
CP_OK   = 5
CP_ERR  = 6
CP_BOX  = 7
CP_INPUT = 8
CP_MATRIX = 9

class InputRequest:
    def __init__(self, kind, prompt, options=None, secret=False):
        self.kind = kind # 'text', 'confirm', 'choice', 'alert'
        self.prompt = prompt
        self.options = options
        self.secret = secret
        self.result = None
        self.event = threading.Event()

class InstallerStep:
    def __init__(self, title, func, step_type='executing'):
        self.title = title
        self.func = func
        self.step_type = step_type # 'interactive' or 'executing'
        self.status = "PENDING" # PENDING, RUNNING, DONE, FAIL
        self.logs = []
        self.start_time = None
        self.end_time = None
        self.return_code = 0
        self.progress = None # 0-100 or None
        self.detail = "" 

    def add_log(self, line):
        self.logs.append(line)
        if len(self.logs) > 500: # Smaller buffer for retro feel
            self.logs = self.logs[-500:]

    def duration(self):
        if self.start_time is None: return 0
        end = self.end_time if self.end_time else time.time()
        return end - self.start_time

class InstallerManager:
    def __init__(self, tui_queue):
        self.steps = []
        self.current_step_idx = -1
        self.stop_requested = False
        self.tui_queue = tui_queue
        self.context = {}
        self.log_file = None
        
        try:
            self.log_file = open("/var/log/install.log", "w")
        except: pass

    @property
    def current_step(self):
        if 0 <= self.current_step_idx < len(self.steps):
            return self.steps[self.current_step_idx]
        return None

    def add_step(self, title, func, step_type='executing'):
        self.steps.append(InstallerStep(title, func, step_type))

    def start(self):
        t = threading.Thread(target=self._run, daemon=True)
        t.start()
        return t

    def _run(self):
        for idx, step in enumerate(self.steps):
            if self.stop_requested: break
            
            self.current_step_idx = idx
            step.status = "RUNNING"
            step.start_time = time.time()
            
            try:
                step.func(self, step)
                step.status = "DONE"
                step.return_code = 0
                step.progress = 100
                step.detail = "Completed."
            except Exception as e:
                step.status = "FAIL"
                tb = traceback.format_exc()
                step.add_log(f"CRITICAL ERROR: {e}")
                for line in tb.splitlines():
                     step.add_log(line)
                
                step.detail = f"FAILED: {e}"
                step.return_code = 1
                self.stop_requested = True
            
            step.end_time = time.time()
            time.sleep(0.5) # Pace it a bit for visuals
            
        if self.log_file:
            self.log_file.close()

    def log(self, text):
        msg = str(text).strip()
        if not msg: return
        if self.current_step:
            self.current_step.add_log(msg)
            # Boot sequence style log to detail if no progress
            if self.current_step.progress is None:
                self.current_step.detail = msg
        if self.log_file:
            try:
                self.log_file.write(f"[{time.strftime('%X')}] {msg}\n")
                self.log_file.flush()
            except: pass

    def run_cmd(self, cmd, shell=False):
        self.log(f"$ {' '.join(cmd) if isinstance(cmd, list) else cmd}")
        process = subprocess.Popen(
            cmd, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.STDOUT, 
            shell=shell, 
            text=True, 
            bufsize=1
        )
        while True:
            line = process.stdout.readline()
            if not line and process.poll() is not None: break
            if line: self.log(line)
        if process.returncode != 0:
            raise Exception(f"Command failed code {process.returncode}")

    def run_with_progress(self, cmd, parser_callback, allowed_codes=[0]):
        self.log(f"EXEC: {' '.join(cmd) if isinstance(cmd, list) else cmd}")
        
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            shell=False,
            text=False, # Binary mode to prevent buffering issues
            bufsize=0
        )

        buffer = b""
        while True:
            # Read larger chunks to drain pipe faster
            chunk = process.stdout.read(1024)
            if not chunk and process.poll() is not None:
                break
            if chunk:
                buffer += chunk
                while b'\n' in buffer or b'\r' in buffer:
                    # Find first separator
                    nl = buffer.find(b'\n')
                    cr = buffer.find(b'\r')
                    
                    split_idx = -1
                    if nl != -1 and cr != -1: split_idx = min(nl, cr)
                    elif nl != -1: split_idx = nl
                    elif cr != -1: split_idx = cr
                    
                    if split_idx != -1:
                        line_bytes = buffer[:split_idx]
                        buffer = buffer[split_idx+1:]
                        if line_bytes.strip():
                            try:
                                line_str = line_bytes.decode('utf-8', errors='replace')
                                parser_callback(line_str)
                            except: pass
        
        if process.returncode not in allowed_codes:
             raise Exception(f"Process failed code {process.returncode}")

    # --- Interaction ---
    def _req(self, req):
        self.tui_queue.put(req)
        req.event.wait()
        return req.result

    def alert(self, msg): self._req(InputRequest('alert', msg))
    def ask_text(self, prompt, secret=False): return self._req(InputRequest('text', prompt, secret=secret))
    def ask_confirm(self, prompt): return self._req(InputRequest('confirm', prompt))
    def ask_choice(self, prompt, options): return self._req(InputRequest('choice', prompt, options=options))


def s_install_base(mgr, step):
    if not shutil.which('rsync'): raise Exception("rsync missing")
    
    excludes = ["/dev/*", "/proc/*", "/sys/*", "/tmp/*", "/run/*", "/mnt/*", "/media/*", "/lost+found"]
    
    # -aAXh for human readable
    # -W: whole file (faster for new install)
    # -x: one-file-system (prevent recursion into /sys /proc /dev if excludes fail)
    cmd = ['rsync', '-aAXhxW', '--info=progress2', '--no-inc-recursive']
    for e in excludes: cmd.append(f'--exclude={e}')
    cmd.extend(['/', f'{MOUNT_POINT}/'])
    
    def rsync_parser(line):
        # 1.23G  45%  45.67MB/s    0:00:12 (xfr#1234, ...
        parts = line.split()
        if len(parts) >= 3 and '%' in parts[1]:
            # parts[0] = Size, parts[1] = %, parts[2] = Speed
            try: step.progress = int(parts[1].strip('%'))
            except: pass
            
            step.detail = f"Transferred: {parts[0]}  |  Speed: {parts[2]}"
            
    # Allow code 24 (Vanished files) which is common on live systems
    mgr.run_with_progress(cmd, rsync_parser, allowed_codes=[0, 24])
    
    # Restore dirs
    for d in ['dev', 'proc', 'sys', 'tmp', 'run', 'mnt', 'media']:
        os.makedirs(os.path.join(MOUNT_POINT, d), exist_ok=True)
    os.chmod(os.path.join(MOUNT_POINT, 'tmp'), 0o1777)


class TUI:
    def __init__(self, stdscr, manager, req_queue):
        self.stdscr = stdscr
        self.mgr = manager
        self.q = req_queue
        self.cur_req = None
        self.last_req = None
        self.inp_buf = ""
        self.choice_idx = 0
        self.h, self.w = 0, 0
        self.tree_w = 30
        self.main_x = 0
        self.main_w = 0
        
        self._init_colors()
        self.stdscr.nodelay(True)
        curses.curs_set(0)

    def _init_colors(self):
        curses.start_color()
        curses.init_pair(CP_BASE, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(CP_HL, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(CP_ACCENT, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(CP_WARN, curses.COLOR_YELLOW, curses.COLOR_BLUE)
        curses.init_pair(CP_OK, curses.COLOR_WHITE, curses.COLOR_GREEN)
        curses.init_pair(CP_ERR, curses.COLOR_WHITE, curses.COLOR_RED)
        curses.init_pair(CP_BOX, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(CP_INPUT, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(CP_MATRIX, curses.COLOR_GREEN, curses.COLOR_BLACK)

    def safe_addstr(self, y, x, text, attr=0, max_w=None):
        if y >= self.h or x >= self.w: return
        
        limit = self.w - x
        if max_w: limit = min(limit, max_w)
        
        # Truncate
        if len(text) > limit:
            text = text[:limit]
            
        # Avoid writing to very last char of screen (fixes scroll error)
        if y == self.h - 1 and x + len(text) == self.w:
            text = text[:-1]
            
        try:
            self.stdscr.addstr(y, x, text, attr)
        except: pass

    def draw_box(self, y, x, h, w, title=""):
        if h < 2 or w < 2: return
        try:
            self.stdscr.attron(curses.color_pair(CP_BOX))
            # Top
            self.safe_addstr(y, x, "╔" + "═" * (w-2) + "╗")
            # Bottom
            self.safe_addstr(y+h-1, x, "╚" + "═" * (w-2) + "╝")
            # Sides & Fill
            for i in range(1, h-1):
                 # Construct line manually to avoid multiple addstrs causing issues
                 line = "║" + " " * (w-2) + "║"
                 self.safe_addstr(y+i, x, line)
            
            if title:
                trunc_title = title[:w-4]
                self.safe_addstr(y, x+2, f" {trunc_title} ", curses.color_pair(CP_ACCENT) | curses.A_BOLD)
            self.stdscr.attroff(curses.color_pair(CP_BOX))
        except: pass

    def handle_input(self):
        try: k = self.stdscr.getch()
        except: k = -1
        if k == -1: return

        if self.cur_req:
            r = self.cur_req
            if r.kind == 'alert' and k in [10, 32]:
                r.result = True; r.event.set(); self.cur_req = None
            elif r.kind == 'confirm':
                if k in [ord('y'), ord('Y'), 10]: 
                    r.result = True; r.event.set(); self.cur_req = None
                elif k in [ord('n'), ord('N'), 27]:
                    r.result = False; r.event.set(); self.cur_req = None
            elif r.kind == 'text':
                if k == 10:
                    r.result = self.inp_buf; r.event.set(); self.cur_req = None; self.inp_buf = ""
                elif k in [127, curses.KEY_BACKSPACE]: self.inp_buf = self.inp_buf[:-1]
                elif 32 <= k <= 126: self.inp_buf += chr(k)
            elif r.kind == 'choice':
                if k == curses.KEY_UP: self.choice_idx = max(0, self.choice_idx - 1)
                elif k == curses.KEY_DOWN: self.choice_idx = min(len(r.options)-1, self.choice_idx + 1)
                elif k == 10:
                    r.result = r.options[self.choice_idx]; r.event.set(); self.cur_req = None; self.choice_idx = 0
        else:
            if k == ord('q'): return 

    def recalc_layout(self):
        # Adaptive Widths
        # If screen is small (< 80), shrink tree
        if self.w < 80:
             self.tree_w = max(20, int(self.w * 0.3))
        else:
             self.tree_w = 30
             
        self.main_x = self.tree_w + 1 # Reduced gap
        self.main_w = max(10, self.w - self.main_x - 1)

    def loop(self):
        while True:
            if not self.cur_req:
                try: 
                    self.cur_req = self.q.get_nowait()
                    self.inp_buf = ""
                    self.choice_idx = 0
                except: pass
            
            # Check resize
            nh, nw = self.stdscr.getmaxyx()
            if nh != self.h or nw != self.w or (self.last_req and not self.cur_req):
                 self.stdscr.erase()
            
            self.h, self.w = nh, nw
            self.recalc_layout()
            self.last_req = self.cur_req
            
            self.handle_input()
            self.draw_ui()
            self.stdscr.refresh()
            curses.napms(50) 

    def draw_ui(self):
        # Header
        header = f" KDOS INSTALLER v{VERSION} "
        self.stdscr.move(0, 0)
        self.stdscr.clrtoeol()
        self.safe_addstr(0, (self.w - len(header))//2, header, curses.color_pair(CP_HL) | curses.A_BOLD)

        # Status Bar
        self.stdscr.move(self.h-1, 0)
        self.stdscr.clrtoeol()
        status = " [Running] " if self.mgr.current_step else " [Idle] "
        if self.cur_req: status = " [Input Required] "
        
        self.safe_addstr(self.h-1, 0, status.center(self.w), curses.color_pair(CP_ACCENT) | curses.A_REVERSE)

        # Draw Boxes
        self.draw_box(2, 0, self.h-4, self.tree_w, "SEQUENCE")
        self.draw_box(2, self.main_x, self.h-4, self.main_w, "OUTPUT")
        
        # Left Panel Content
        content_w = self.tree_w - 2
        for i, step in enumerate(self.mgr.steps):
            y = 3 + i
            if y >= self.h - 3: break
            
            marker = "[ ]"
            attr = curses.color_pair(CP_BASE)
            if step.status == "DONE": marker = "[X]"; attr = curses.color_pair(CP_BASE)
            elif step.status == "RUNNING": marker = "[>]"; attr = curses.color_pair(CP_WARN) | curses.A_BOLD
            elif step.status == "FAIL": marker = "[!]"; attr = curses.color_pair(CP_ERR) | curses.A_BOLD
            
            # Fill Background
            self.safe_addstr(y, 1, " " * content_w, curses.color_pair(CP_BOX))
            
            text = f"{marker} {step.title}"
            if len(text) > content_w: text = text[:content_w] # Strict chop
            
            # Selected Highlight
            line_attr = attr
            if i == self.mgr.current_step_idx:
                line_attr = curses.color_pair(CP_HL)
                text = text.ljust(content_w) # Ensure highlight fills line
            
            self.safe_addstr(y, 2, text, line_attr)

        # Right Panel Content
        step = self.mgr.current_step
        if step:
            content_mw = self.main_w - 4 # Padding for borders
            mx = self.main_x + 2         # Padding for left border + space
            
            # Step Title
            title_str = f">> {step.title.upper()} <<"
            self.safe_addstr(3, mx + (content_mw - len(title_str))//2, title_str, curses.color_pair(CP_ACCENT) | curses.A_BOLD)
            
            # Progress Bar
            pct = step.progress if step.progress is not None else 0
            bar_w = content_mw - 2
            filled = int(bar_w * (pct / 100))
            bar = "▓" * filled + "░" * (bar_w - filled)
            
            pct_str = f" {pct}% " if step.progress is not None else " BUSY "
            
            self.safe_addstr(5, mx + 1, bar, curses.color_pair(CP_BASE))
            self.safe_addstr(5, mx + 1 + (bar_w - len(pct_str))//2, pct_str, curses.color_pair(CP_HL))

            # Detail Line
            detail_trunc = (step.detail or "")
            if len(detail_trunc) > content_mw: detail_trunc = detail_trunc[:content_mw]
            
            self.safe_addstr(7, mx, " " * content_mw, curses.color_pair(CP_BOX)) # Clear
            self.safe_addstr(7, mx, detail_trunc, curses.color_pair(CP_ACCENT))

            # Logs
            log_h = self.h - 14
            logs = step.logs[-log_h:]
            for i, l in enumerate(logs):
                # Clear line
                self.safe_addstr(9+i, mx, " " * content_mw, curses.color_pair(CP_BOX))
                if len(l) > content_mw: l = l[:content_mw]
                self.safe_addstr(9+i, mx, l, curses.color_pair(CP_BASE))

        # Overlay Input (Centered)
        if self.cur_req:
            self.draw_overlay(self.cur_req)

    def draw_overlay(self, req):
        bw = min(60, self.w - 4)
        prompt_lines = req.prompt.split('\n')
        bh = len(prompt_lines) + 6
        if req.kind == 'choice': bh += len(req.options)
        
        bx = (self.w - bw)//2
        by = (self.h - bh)//2
        
        # Draw Box manually with safe_addstr
        self.stdscr.attron(curses.color_pair(CP_INPUT))
        self.safe_addstr(by, bx, "╔" + "═"*(bw-2) + "╗")
        self.safe_addstr(by+bh-1, bx, "╚" + "═"*(bw-2) + "╝")
        for i in range(1, bh-1):
            self.safe_addstr(by+i, bx, "║" + " "*(bw-2) + "║")
        
        self.safe_addstr(by, bx+2, " REQUEST ", curses.A_REVERSE | curses.A_BOLD)
        
        for i, l in enumerate(prompt_lines):
            self.safe_addstr(by+2+i, bx+3, l[:bw-4])
            
        cy = by + 3 + len(prompt_lines)
        
        if req.kind == 'text':
            self.safe_addstr(cy, bx+3, ("> " + self.inp_buf + "_")[:bw-4], curses.A_BOLD)
        elif req.kind == 'confirm':
             msg = "[ Y / N ]"
             self.safe_addstr(cy, bx+(bw-len(msg))//2, msg, curses.A_REVERSE)
        elif req.kind == 'choice':
            for i, o in enumerate(req.options):
                prefix = "[x]" if i == self.choice_idx else "[ ]"
                style = curses.A_REVERSE if i == self.choice_idx else curses.A_NORMAL
                text = f"{prefix} {o}"
                self.safe_addstr(cy+i, bx+5, text[:bw-6], style)
        elif req.kind == 'alert':
             msg = "[ OK ]"
             self.safe_addstr(cy, bx+(bw-len(msg))//2, msg, curses.A_REVERSE)
        
        self.stdscr.attroff(curses.color_pair(CP_INPUT))

    def draw_overlay(self, req):
        bw = 60
        prompt_lines = req.prompt.split('\n')
        bh = len(prompt_lines) + 6
        if req.kind == 'choice': bh += len(req.options)
        
        bx = (self.w - bw)//2
        by = (self.h - bh)//2
        
        # Background
        for i in range(bh):
            self.stdscr.addstr(by+i, bx, " " * bw, curses.color_pair(CP_INPUT))
            
        self.stdscr.attron(curses.color_pair(CP_INPUT))
        self.stdscr.addstr(by, bx, "╔" + "═"*(bw-2) + "╗")
        self.stdscr.addstr(by+bh-1, bx, "╚" + "═"*(bw-2) + "╝")
        for i in range(1, bh-1):
            self.stdscr.addstr(by+i, bx, "║"); self.stdscr.addstr(by+i, bx+bw-1, "║")
        
        self.stdscr.addstr(by, bx+2, " REQUEST ", curses.A_REVERSE | curses.A_BOLD)
        
        for i, l in enumerate(prompt_lines):
            self.stdscr.addstr(by+2+i, bx+3, l)
            
        cy = by + 3 + len(prompt_lines)
        
        if req.kind == 'text':
            self.stdscr.addstr(cy, bx+3, "> " + self.inp_buf + "_", curses.A_BOLD)
        elif req.kind == 'confirm':
             self.stdscr.addstr(cy, bx+(bw-10)//2, "[ Y / N ]", curses.A_REVERSE)
        elif req.kind == 'choice':
            for i, o in enumerate(req.options):
                prefix = "[x]" if i == self.choice_idx else "[ ]"
                style = curses.A_REVERSE if i == self.choice_idx else curses.A_NORMAL
                self.stdscr.addstr(cy+i, bx+5, f"{prefix} {o}", style)
        elif req.kind == 'alert':
             self.stdscr.addstr(cy, bx+(bw-6)//2, "[ OK ]", curses.A_REVERSE)
        
        self.stdscr.attroff(curses.color_pair(CP_INPUT))

# --- Utils ---
def unmount_disk(mgr, disk):
    """Force unmount partitions on disk."""
    mgr.log(f"Unmounting partitions on {disk}...")
    try:
        # Read mounts
        parts = []
        with open("/proc/mounts", "r") as f:
            for line in f:
                if disk in line:
                    parts.append(line.split()[1])
        
        for p in parts:
            mgr.log(f"Unmounting {p}...")
            # Use run_cmd to capture output
            try: mgr.run_cmd(['umount', '-l', p])
            except: pass
            
        try: mgr.run_cmd(['swapoff', '-a'])
        except: pass
    except Exception as e:
        mgr.log(f"Unmount warning: {e}")

def get_disk_info(disk):
    try:
        # stderr to DEVNULL to avoid leaks
        out = subprocess.check_output(['lsblk', disk, '-n', '-o', 'NAME,SIZE,TYPE,FSTYPE,MOUNTPOINT'], text=True, stderr=subprocess.DEVNULL)
        return out.strip()
    except: return "Unknown"

# --- Steps ---

def s_init(mgr, step):
    mgr.log("Initializing core systems...")
    time.sleep(1)
    if os.geteuid() != 0:
        mgr.alert("ROOT PRIVILEGES REQUIRED. ABORTING.")
        raise Exception("Not Root")

def s_gather_info(mgr, step):
    # Welcome
    if not mgr.ask_confirm("Welcome to KDOS Installer.\nWARNING: DISK WILL BE WIPED.\nProceed?"):
        raise Exception("User Cancelled")
        
    # Disk Select
    mgr.log("Scanning bus...")
    try:
        output = subprocess.check_output(['lsblk', '-d', '-n', '-p', '-o', 'NAME,SIZE,MODEL'], text=True, stderr=subprocess.DEVNULL)
        lines = [l for l in output.splitlines() if l.strip()]
        disks = []
        for line in lines:
            if 'loop' in line or 'sr' in line: continue
            disks.append(line.strip())
            
        if not disks: raise Exception("No disks found")
        
        choice = mgr.ask_choice("Select Target Disk:", disks)
        disk = choice.split()[0]
        mgr.context['disk'] = disk
        
        # Disk layout preview
        curr_info = get_disk_info(disk)
        preview = (
            f"TARGET: {disk}\n\n"
            f"--- CURRENT LAYOUT ---\n{curr_info}\n\n"
            f"--- NEW LAYOUT ---\n"
            f"1. EFI System (512MB, FAT32)\n"
            f"2. Linux Root (Rest, EXT4)"
        )
        if not mgr.ask_confirm(f"{preview}\n\nACCEPT LAYOUT AND DESTROY DATA?"):
            raise Exception("Layout Rejected")
            
        # Hostname
        hostname = mgr.ask_text("Hostname:")
        if not hostname: hostname = "kdos"
        mgr.context['hostname'] = hostname
        
    except Exception as e:
        raise e

def s_partition(mgr, step):
    disk = mgr.context['disk']
    unmount_disk(mgr, disk)
    
    mgr.log(f"Wiping {disk}...")
    mgr.run_cmd(['wipefs', '-a', disk])
    
    mgr.log("Partitioning...")
    # Scripted sfdisk
    layout = "label: gpt\n,512M,U\n,,L"
    p = subprocess.Popen(['sfdisk', disk], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    o, e = p.communicate(input=layout)
    
    # Log the output to TUI
    if o:
        for line in o.splitlines():
            mgr.log(line)
            
    if p.returncode != 0: raise Exception(f"sfdisk failed: {o}")
    
    time.sleep(1)
    # Detect partitions
    if re.search(r'\d$', disk):
        mgr.context['efi'] = f"{disk}p1"
        mgr.context['root'] = f"{disk}p2"
    else:
        mgr.context['efi'] = f"{disk}1"
        mgr.context['root'] = f"{disk}2"

def s_format(mgr, step):
    mgr.run_cmd(['mkfs.ext4', '-F', mgr.context['root']])
    mgr.run_cmd(['mkfs.vfat', '-F', '32', mgr.context['efi']])

def s_mount(mgr, step):
    os.makedirs(MOUNT_POINT, exist_ok=True)
    mgr.run_cmd(['mount', mgr.context['root'], MOUNT_POINT])
    os.makedirs(os.path.join(MOUNT_POINT, "boot/efi"), exist_ok=True)
    mgr.run_cmd(['mount', mgr.context['efi'], os.path.join(MOUNT_POINT, "boot/efi")])

def s_install_base(mgr, step):
    if not shutil.which('rsync'): raise Exception("rsync missing")
    
    excludes = ["/dev/*", "/proc/*", "/sys/*", "/tmp/*", "/run/*", "/mnt/*", "/media/*", "/lost+found"]
    
    # -aAXh for human readable. --no-inc-recursive for better progress stats
    cmd = ['rsync', '-aAXh', '--info=progress2', '--no-inc-recursive']
    for e in excludes: cmd.append(f'--exclude={e}')
    cmd.extend(['/', f'{MOUNT_POINT}/'])
    
    def rsync_parser(line):
        # 1.23G  45%  45.67MB/s    0:00:12 (xfr#1234, ...
        parts = line.split()
        if len(parts) >= 3 and '%' in parts[1]:
            # parts[0] = Size, parts[1] = %, parts[2] = Speed
            try: step.progress = int(parts[1].strip('%'))
            except: pass
            
            step.detail = f"Transferred: {parts[0]}  |  Speed: {parts[2]}"

    mgr.run_with_progress(cmd, rsync_parser)
    
    # Restore dirs
    for d in ['dev', 'proc', 'sys', 'tmp', 'run', 'mnt', 'media']:
        os.makedirs(os.path.join(MOUNT_POINT, d), exist_ok=True)
    os.chmod(os.path.join(MOUNT_POINT, 'tmp'), 0o1777)

def s_configure(mgr, step):
    # Fstab
    mgr.log("Generating fstab...")
    r_uuid = subprocess.check_output(['blkid', '-s', 'UUID', '-o', 'value', mgr.context['root']], text=True).strip()
    e_uuid = subprocess.check_output(['blkid', '-s', 'UUID', '-o', 'value', mgr.context['efi']], text=True).strip()
    
    with open(f"{MOUNT_POINT}/etc/fstab", 'w') as f:
        f.write(f"UUID={r_uuid} / ext4 defaults,noatime 0 1\n")
        f.write(f"UUID={e_uuid} /boot/efi vfat defaults 0 2\n")
        
    # Hostname
    with open(f"{MOUNT_POINT}/etc/hostname", 'w') as f:
        f.write(mgr.context['hostname'] + "\n")
        
    if os.path.exists("/etc/resolv.conf"):
        shutil.copy("/etc/resolv.conf", f"{MOUNT_POINT}/etc/resolv.conf")
        
    # Boot config
    with open(f"{MOUNT_POINT}/boot/refind_linux.conf", 'w') as f:
         f.write(f'"Standard" "ro root=UUID={r_uuid} initrd=boot/initramfs.cpio.gz quiet"\n')

def s_bootloader(mgr, step):
    # Same logic as before roughly
    src = "/usr/share/refind"
    if not os.path.exists(src): src = f"{MOUNT_POINT}/usr/share/refind"
    
    target = f"{MOUNT_POINT}/boot/efi/EFI/refind"
    if os.path.exists(target): shutil.rmtree(target)
    shutil.copytree(src, target)
    
    # Fallback
    boot = f"{MOUNT_POINT}/boot/efi/EFI/BOOT"
    if os.path.exists(boot): shutil.rmtree(boot)
    shutil.copytree(target, boot)
    
    if os.path.exists(f"{boot}/refind_x64.efi"):
        shutil.move(f"{boot}/refind_x64.efi", f"{boot}/bootx64.efi")
        
    # sample configs
    for d in [target, boot]:
        if os.path.exists(f"{d}/refind.conf-sample"):
             shutil.copy(f"{d}/refind.conf-sample", f"{d}/refind.conf")

    mgr.log("Bootloader files installed.")

def s_reboot(mgr, step):
    mgr.alert("INSTALLATION COMPLETE.\nREMOVE MEDIA AND REBOOT.")
    if mgr.ask_confirm("Reboot now?"):
        curses.endwin()
        os.system("reboot")
    else:
        sys.exit(0)

# --- Main ---
def main(stdscr):
    q = queue.Queue()
    mgr = InstallerManager(q)
    
    mgr.add_step("Initialization", s_init)
    mgr.add_step("Configuration", s_gather_info, step_type='interactive')
    mgr.add_step("Partition Disk", s_partition)
    mgr.add_step("Format Filesystem", s_format)
    mgr.add_step("Mount Target", s_mount)
    mgr.add_step("Install System", s_install_base)
    mgr.add_step("System Config", s_configure)
    mgr.add_step("Bootloader", s_bootloader)
    mgr.add_step("Finalize", s_reboot, step_type='interactive')
    
    tui = TUI(stdscr, mgr, q)
    mgr.start()
    tui.loop()

if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        sys.exit(1)
