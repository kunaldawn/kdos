#!/usr/bin/env python3

# ██╗  ██╗██████╗  ██████╗ ███████╗
# ██║ ██╔╝██╔══██╗██╔═══██╗██╔════╝
# █████╔╝ ██║  ██║██║   ██║███████╗
# ██╔═██╗ ██║  ██║██║   ██║╚════██║
# ██║  ██╗██████╔╝╚██████╔╝███████║
# ╚═╝  ╚═╝╚═════╝  ╚═════╝ ╚══════╝
# ---------------------------------
#    KDOS Installer
# ---------------------------------

import curses
import curses.textpad
import sys
import os
import time
import subprocess
import threading
import queue
import re
import shutil

# --- Configuration ---
VERSION = "2.0-dashboard"
MOUNT_POINT = "/mnt"

# Colors (Global constants to match build.py)
CP_BG = 1       
CP_HL = 2       
CP_RUN = 3      
CP_DONE = 4     
CP_FAIL = 5     
CP_TITLE = 6    
CP_BAR = 7      
CP_LOG = 8      
CP_TIME = 9     
CP_KEY = 10     
CP_DONE_REV = 11
CP_TRACK = 12   
CP_RUN_SEL = 13
CP_INPUT = 14 # New for input box

class InputRequest:
    def __init__(self, kind, prompt, options=None, secret=False):
        self.kind = kind # 'text', 'confirm', 'choice', 'alert'
        self.prompt = prompt
        self.options = options
        self.secret = secret
        self.result = None
        self.event = threading.Event()

class InstallerStep:
    def __init__(self, title, func):
        self.title = title
        self.func = func
        self.status = "PENDING" # PENDING, RUNNING, DONE, FAIL
        self.logs = []
        self.start_time = None
        self.end_time = None
        self.return_code = 0
        
    def add_log(self, line):
        self.logs.append(line)
        if len(self.logs) > 2000:
            self.logs = self.logs[-2000:]
            
    def duration(self):
        if self.start_time is None: return 0
        end = self.end_time if self.end_time else time.time()
        return end - self.start_time

class InstallerManager:
    def __init__(self, tui_queue):
        self.steps = []
        self.current_step = None
        self.stop_requested = False
        self.tui_queue = tui_queue # Queue to send requests to TUI
        self.context = {} # Shared state between steps
        self.log_file = None
        
        try:
            self.log_file = open("/var/log/install.log", "w")
        except:
            # Fallback if not root or filtered, though script requires root
            pass

    def add_step(self, title, func):
        self.steps.append(InstallerStep(title, func))

    def start(self):
        t = threading.Thread(target=self._run, daemon=True)
        t.start()
        return t

    def _run(self):
        for step in self.steps:
            if self.stop_requested: break
            
            self.current_step = step
            step.status = "RUNNING"
            step.start_time = time.time()
            
            try:
                # Execute the step function, passing self as context provider
                step.func(self, step)
                step.status = "DONE"
                step.return_code = 0
            except Exception as e:
                step.status = "FAIL"
                step.add_log(f"ERROR: {e}")
                step.return_code = 1
                self.stop_requested = True
            
            step.end_time = time.time()
            
        if self.log_file:
            self.log_file.close()
            
    # --- Helper methods for steps to interact with UI/System ---
    def log(self, text):
        msg = str(text)
        if self.current_step:
            self.current_step.add_log(msg)
        if self.log_file:
            try:
                self.log_file.write(f"[{time.strftime('%X')}] {msg}\n")
                self.log_file.flush()
            except: pass

    def run_cmd(self, cmd, shell=False):
        if self.current_step:
            self.current_step.add_log(f"$ {' '.join(cmd) if isinstance(cmd, list) else cmd}")
        
        # We want to capture output and stream it to logs
        process = subprocess.Popen(
            cmd, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.STDOUT, 
            shell=shell, 
            text=True, 
            bufsize=1
        )
        
        while True:
            line = process.stdout.readline()
            if not line and process.poll() is not None:
                break
            if line:
                self.log(line.strip())
                
        if process.returncode != 0:
            raise Exception(f"Command failed with code {process.returncode}")

    # --- Interaction Requests ---
    def _request_input(self, req):
        self.tui_queue.put(req)
        req.event.wait()
        return req.result

    def alert(self, msg):
        self._request_input(InputRequest('alert', msg))

    def ask_text(self, prompt, secret=False):
        return self._request_input(InputRequest('text', prompt, secret=secret))

    def ask_confirm(self, prompt):
        return self._request_input(InputRequest('confirm', prompt))

    def ask_choice(self, prompt, options):
        return self._request_input(InputRequest('choice', prompt, options=options))


class TUI:
    def __init__(self, stdscr, manager, req_queue):
        self.stdscr = stdscr
        self.manager = manager
        self.req_queue = req_queue
        self.current_input_req = None
        self.input_buffer = ""
        self.choice_index = 0
        
        self.selected_step_index = 0
        self.scroll_offset = 0
        self.auto_follow = True
        
        self.h, self.w = 0, 0
        self._init_colors()
        
        # Setup input
        self.stdscr.nodelay(True)
        self.stdscr.keypad(True)
        curses.curs_set(0)

    def _init_colors(self):
        try:
            curses.start_color()
            curses.init_pair(CP_BG, curses.COLOR_WHITE, curses.COLOR_BLACK)
            curses.init_pair(CP_HL, curses.COLOR_WHITE, curses.COLOR_BLUE)
            curses.init_pair(CP_RUN, curses.COLOR_YELLOW, curses.COLOR_BLACK)
            curses.init_pair(CP_DONE, curses.COLOR_GREEN, curses.COLOR_BLACK)
            curses.init_pair(CP_FAIL, curses.COLOR_RED, curses.COLOR_BLACK)
            curses.init_pair(CP_TITLE, curses.COLOR_CYAN, curses.COLOR_BLACK)
            curses.init_pair(CP_BAR, curses.COLOR_BLUE, curses.COLOR_BLACK)
            curses.init_pair(CP_LOG, curses.COLOR_WHITE, curses.COLOR_BLACK)
            curses.init_pair(CP_TIME, curses.COLOR_CYAN, curses.COLOR_BLACK)
            curses.init_pair(CP_KEY, curses.COLOR_YELLOW, curses.COLOR_BLACK)
            curses.init_pair(CP_DONE_REV, curses.COLOR_BLACK, curses.COLOR_GREEN)
            curses.init_pair(CP_TRACK, curses.COLOR_WHITE, curses.COLOR_BLACK)
            curses.init_pair(CP_RUN_SEL, curses.COLOR_YELLOW, curses.COLOR_BLUE)
            curses.init_pair(CP_INPUT, curses.COLOR_WHITE, curses.COLOR_BLUE) # Input box style
        except: pass

    def update_dims(self):
        self.h, self.w = self.stdscr.getmaxyx()

    def process_input(self):
        try:
            key = self.stdscr.getch()
        except: key = -1
        
        if key == -1: return

        # Check for input request first
        if self.current_input_req:
            self._handle_input_req(key)
            return

        # Normal navigation
        if key == ord('q'):
            if self.manager.current_step is None or self.manager.stop_requested: # If idle or done
                sys.exit(0)
            # else ignore or confirm cancel? For now ignore.
        
        elif key == curses.KEY_UP:
            self.selected_step_index = max(0, self.selected_step_index - 1)
            self.auto_follow = False
        elif key == curses.KEY_DOWN:
            self.selected_step_index = min(len(self.manager.steps) - 1, self.selected_step_index + 1)
            self.auto_follow = False
        elif key == ord('f'):
            self.auto_follow = not self.auto_follow

    def _handle_input_req(self, key):
        req = self.current_input_req
        
        if req.kind == 'alert':
            if key == 10 or key == 32: # Enter or Space
                req.result = True
                req.event.set()
                self.current_input_req = None
        
        elif req.kind == 'confirm':
            # y/n logic
            if key in [ord('y'), ord('Y')]:
                req.result = True
                req.event.set()
                self.current_input_req = None
            elif key in [ord('n'), ord('N')]:
                req.result = False
                req.event.set()
                self.current_input_req = None
        
        elif req.kind == 'text':
            if key == 10: # Enter
                req.result = self.input_buffer
                req.event.set()
                self.current_input_req = None
                self.input_buffer = ""
            elif key == 27: # Esc (Empty)
                req.result = ""
                req.event.set()
                self.current_input_req = None
                self.input_buffer = ""
            elif key == curses.KEY_BACKSPACE or key == 127:
                self.input_buffer = self.input_buffer[:-1]
            elif 32 <= key <= 126:
                self.input_buffer += chr(key)
        
        elif req.kind == 'choice':
            if key == curses.KEY_UP:
                self.choice_index = max(0, self.choice_index - 1)
            elif key == curses.KEY_DOWN:
                self.choice_index = min(len(req.options) - 1, self.choice_index + 1)
            elif key == 10: # Enter
                req.result = req.options[self.choice_index]
                req.event.set()
                self.current_input_req = None
                self.choice_index = 0

    def loop(self):
        while True:
            # Check for new input requests
            try:
                if not self.current_input_req:
                    req = self.req_queue.get_nowait()
                    self.current_input_req = req
                    self.input_buffer = ""
                    self.choice_index = 0
            except queue.Empty: pass
            
            self.update_dims()
            self.process_input()
            
            if self.auto_follow and self.manager.current_step:
                for i, s in enumerate(self.manager.steps):
                    if s == self.manager.current_step:
                        self.selected_step_index = i
                        break
            
            self.draw_screen()
            time.sleep(0.05)

    def draw_screen(self):
        self.stdscr.bkgd(' ', curses.color_pair(CP_BG))
        self.stdscr.erase()
        
        try:
            # -- DRAW TREE (LEFT) --
            tree_w = int(self.w * 0.35)
            tree_w = max(25, min(tree_w, 40))
            
            # Border
            for y in range(self.h):
                self.stdscr.addch(y, tree_w, curses.ACS_VLINE, curses.color_pair(CP_TITLE))
            
            self.draw_tree(tree_w)
            
            # -- DRAW DETAIL (RIGHT) --
            detail_x = tree_w + 1
            detail_w = self.w - detail_x
            
            self.draw_detail(detail_x, detail_w)
            
            # -- DRAW OVERLAYS --
            if self.current_input_req:
                self.draw_overlay(self.current_input_req)

        except curses.error: pass
        self.stdscr.refresh()

    def draw_tree(self, w):
        # Header
        self.stdscr.addstr(0, 0, " KDOS INSTALLER ".center(w), curses.color_pair(CP_RUN) | curses.A_BOLD)
        
        start_y = 2
        
        # Scroll logic
        # simple window
        list_h = self.h - 4
        if self.selected_step_index < self.scroll_offset:
            self.scroll_offset = self.selected_step_index
        elif self.selected_step_index >= self.scroll_offset + list_h:
            self.scroll_offset = self.selected_step_index - list_h + 1
            
        for i in range(list_h):
            idx = self.scroll_offset + i
            if idx >= len(self.manager.steps): break
            
            step = self.manager.steps[idx]
            y = start_y + i
            
            # Icon
            icon = "    "
            attr = curses.color_pair(CP_BG)
            if step.status == "RUNNING":
                frames = ["⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷"]
                f = frames[int(time.time() * 10) % 8]
                icon = f" {f}  "
                attr = curses.color_pair(CP_RUN) | curses.A_BOLD
            elif step.status == "DONE":
                icon = " OK "
                attr = curses.color_pair(CP_DONE_REV) | curses.A_BOLD
            elif step.status == "FAIL":
                icon = " !! "
                attr = curses.color_pair(CP_FAIL) | curses.A_BOLD
            
            # Draw Line
            is_sel = (idx == self.selected_step_index)
            line_attr = curses.color_pair(CP_HL) if is_sel else curses.color_pair(CP_BG)
            if is_sel and step.status == "RUNNING": 
                # Icon background fix for running selected
                pass
            
            # Draw full line background if selected
            self.stdscr.addstr(y, 0, " " * w, line_attr)
            
            # Icon
            self.stdscr.addstr(y, 1, icon, attr)
            
            # Text
            title = step.title[:w-6]
            self.stdscr.addstr(y, 6, title, line_attr | curses.A_BOLD)

    def draw_detail(self, x, w):
        if not self.manager.steps: return
        step = self.manager.steps[self.selected_step_index]
        
        # Header Box
        header_attr = curses.color_pair(CP_TITLE) | curses.A_BOLD
        if step.status == "RUNNING": header_attr = curses.color_pair(CP_RUN) | curses.A_BOLD
        elif step.status == "FAIL": header_attr = curses.color_pair(CP_FAIL) | curses.A_BOLD
        
        self.stdscr.addstr(1, x + 2, f" STEP: {step.title} ".ljust(w-4), header_attr)
        
        status_line = f" STATUS: {step.status} "
        if step.duration() > 0: status_line += f"({step.duration():.1f}s)"
        self.stdscr.addstr(2, x + 2, status_line.ljust(w-4), curses.color_pair(CP_BG) | curses.A_BOLD)
        
        # Separator
        self.stdscr.addstr(3, x, " " * w, curses.color_pair(CP_BG) | curses.A_UNDERLINE)
        
        # Logs
        log_y = 4
        log_h = self.h - 5
        visible_logs = step.logs[-log_h:]
        
        for i, line in enumerate(visible_logs):
            clean = line.replace('\t', '    ')
            self.stdscr.addstr(log_y + i, x + 2, clean[:w-4], curses.color_pair(CP_LOG))

    def draw_overlay(self, req):
        # Calculate height based on prompt lines
        # Default prompt width 60
        bw = 60
        prompt_lines = req.prompt.split('\n')
        
        # Calculate dynamic height: 
        # Base padding: 2 (top) + 1 (spacing) + 2 (bottom/buttons) + 2 (borders) = 7?
        # Let's count rows:
        # 0: Border
        # 1: Padding
        # 2..N: Text
        # N+1: Spacing
        # N+2..M: Controls
        # M+1: Padding
        # M+2: Border
        
        text_h = len(prompt_lines)
        controls_h = 1
        if req.kind == 'choice':
            controls_h = len(req.options)
            
        bh = 2 + 1 + text_h + 1 + controls_h + 1 # Borders(2) + PadTop(1) + Text + Gap(1) + Controls + PadBot(1)
            
        bx = (self.w - bw) // 2
        by = (self.h - bh) // 2
        
        # Box Loop
        self.stdscr.attron(curses.color_pair(CP_INPUT))
        for i in range(bh):
            self.stdscr.addstr(by + i, bx, " " * bw)
            
        # Draw border manually
        self.stdscr.addstr(by, bx, "+" + "-" * (bw-2) + "+")
        self.stdscr.addstr(by + bh - 1, bx, "+" + "-" * (bw-2) + "+")
        for i in range(1, bh - 1):
            self.stdscr.addstr(by + i, bx, "|")
            self.stdscr.addstr(by + i, bx + bw - 1, "|")
        self.stdscr.attroff(curses.color_pair(CP_INPUT))
        
        # Title/Prompt (Multi-line)
        for i, line in enumerate(prompt_lines):
            self.stdscr.addstr(by + 2 + i, bx + 2, line[:bw-4], curses.color_pair(CP_INPUT) | curses.A_BOLD)
        
        # Controls Position
        cy = by + 2 + text_h + 1
        
        if req.kind == 'alert':
            self.stdscr.addstr(cy, bx + (bw - 8)//2, "[ OK ]", curses.color_pair(CP_INPUT) | curses.A_REVERSE)
            
        elif req.kind == 'confirm':
            self.stdscr.addstr(cy, bx + (bw - 17)//2, "[Y] Yes   [N] No", curses.color_pair(CP_INPUT))
            
        elif req.kind == 'text':
            self.stdscr.addstr(cy, bx + 4, "> " + self.input_buffer + "_", curses.color_pair(CP_LOG))
            
        elif req.kind == 'choice':
            for i, opt in enumerate(req.options):
                prefix = "(*)" if i == self.choice_index else "( )"
                style = curses.A_REVERSE if i == self.choice_index else curses.A_NORMAL
                self.stdscr.addstr(cy + i, bx + 4, f"{prefix} {opt}", curses.color_pair(CP_INPUT) | style)


# --- Step Functions ---

def s_welcome(mgr, step):
    mgr.log("Initializing installer...")
    time.sleep(1)
    
    mgr.alert("Welcome to the KDOS Installer.\nWARNING: This process is destructive!")
    if not mgr.ask_confirm("Do you want to proceed?"):
        mgr.log("User cancelled.")
        raise Exception("Cancelled by user")

def s_select_disk(mgr, step):
    mgr.log("Scanning for disks...")
    
    # Mock scan or real scan
    try:
        output = subprocess.check_output(['lsblk', '-d', '-n', '-p', '-o', 'NAME,SIZE,MODEL'], text=True)
        lines = [l for l in output.splitlines() if l.strip()]
        disks = []
        for line in lines:
            if 'loop' in line or 'sr' in line: continue
            parts = line.split(None, 2)
            if len(parts) >= 2:
                model = parts[2] if len(parts) > 2 else "Unknown"
                disks.append(f"{parts[0]} ({parts[1]}) - {model}")
                
        if not disks:
            raise Exception("No suitable disks found!")
            
        choice = mgr.ask_choice("Select Installation Disk:", disks)
        mgr.context['disk'] = choice.split()[0]
        mgr.log(f"Selected disk: {mgr.context['disk']}")
        
        if not mgr.ask_confirm(f"ALL DATA on {mgr.context['disk']} will be ERASED. Confirm?"):
            raise Exception("User rejected disk wipe")
            
    except Exception as e:
        mgr.log(f"Disk selection failed: {e}")
        raise e

def s_partition(mgr, step):
    disk = mgr.context.get('disk')
    mgr.log(f"Wiping {disk}...")
    mgr.run_cmd(['wipefs', '-a', disk])
    
    mgr.log("Partitioning (GPT)...")
    sfdisk_input = "label: gpt\n,512M,U\n,,L"
    
    proc = subprocess.Popen(['sfdisk', disk], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    out, err = proc.communicate(input=sfdisk_input)
    if proc.returncode != 0:
        mgr.log(f"sfdisk error: {err}")
        raise Exception("sfdisk failed")
        
    mgr.log(out)
    mgr.log("Waiting for block devices...")
    time.sleep(2)
    
    # Identify parts
    if re.search(r'\d$', disk):
        mgr.context['efi'] = f"{disk}p1"
        mgr.context['root'] = f"{disk}p2"
    else:
        mgr.context['efi'] = f"{disk}1"
        mgr.context['root'] = f"{disk}2"

def s_format(mgr, step):
    mgr.log(f"Formatting ROOT: {mgr.context['root']} (ext4)")
    mgr.run_cmd(['mkfs.ext4', '-F', mgr.context['root']])
    
    mgr.log(f"Formatting EFI: {mgr.context['efi']} (vfat)")
    mgr.run_cmd(['mkfs.vfat', '-F', '32', mgr.context['efi']])

def s_mount(mgr, step):
    mgr.log(f"Mounting ROOT to {MOUNT_POINT}")
    os.makedirs(MOUNT_POINT, exist_ok=True)
    mgr.run_cmd(['mount', mgr.context['root'], MOUNT_POINT])
    
    mgr.log(f"Mounting EFI to {MOUNT_POINT}/boot/efi")
    os.makedirs(os.path.join(MOUNT_POINT, "boot/efi"), exist_ok=True)
    mgr.run_cmd(['mount', mgr.context['efi'], os.path.join(MOUNT_POINT, "boot/efi")])

def s_install_base(mgr, step):
    if not shutil.which('rsync'):
        raise Exception("rsync not found")
        
    excludes = ["/dev/*", "/proc/*", "/sys/*", "/tmp/*", "/run/*", "/mnt/*", "/media/*", "/lost+found"]
    cmd = ['rsync', '-aAX', '--info=progress2']
    for exc in excludes:
        cmd.append(f'--exclude={exc}')
    cmd.extend(['/', f'{MOUNT_POINT}/'])
    
    mgr.log("Starting rsync (this will take time)...")
    # Note: run_cmd captures output so progress might be verbose or buffered. 
    # For better TUI, we just let it run.
    mgr.run_cmd(cmd)
    
    # dirs
    for d in ['dev', 'proc', 'sys', 'tmp', 'run', 'mnt', 'media']:
        os.makedirs(os.path.join(MOUNT_POINT, d), exist_ok=True)
    os.chmod(os.path.join(MOUNT_POINT, 'tmp'), 0o1777)

def s_configure(mgr, step):
    # Fstab
    mgr.log("Generating fstab...")
    root_uuid = subprocess.check_output(['blkid', '-s', 'UUID', '-o', 'value', mgr.context['root']], text=True).strip()
    efi_uuid = subprocess.check_output(['blkid', '-s', 'UUID', '-o', 'value', mgr.context['efi']], text=True).strip()
    
    with open(os.path.join(MOUNT_POINT, "etc/fstab"), 'w') as f:
        f.write(f"UUID={root_uuid}  /          ext4    defaults,noatime 0 1\n")
        f.write(f"UUID={efi_uuid}   /boot/efi  vfat    defaults         0 2\n")
        
    # Hostname
    hostname = mgr.ask_text("Enter Hostname:")
    if not hostname: hostname = "kdos"
    with open(os.path.join(MOUNT_POINT, "etc/hostname"), 'w') as f:
        f.write(hostname + "\n")
        
    if os.path.exists("/etc/resolv.conf"):
        shutil.copy("/etc/resolv.conf", os.path.join(MOUNT_POINT, "etc/resolv.conf"))

    # boot config
    mgr.log("Generating refind_linux.conf...")
    refind_conf = os.path.join(MOUNT_POINT, "boot/refind_linux.conf")
    with open(refind_conf, 'w') as f:
        f.write(f'"Boot with standard options" "ro root=UUID={root_uuid} initrd=boot/initramfs.cpio.gz loglevel=3 quiet"\n')
        f.write(f'"Boot to console" "ro root=UUID={root_uuid} initrd=boot/initramfs.cpio.gz loglevel=3 quiet systemd.unit=multi-user.target"\n')

def s_bootloader(mgr, step):
    mgr.log("Installing Bootloader (rEFInd - Manual Mode)...")
    
    # Define paths
    # Source: we assume rEFInd is installed in the live environment at /usr/share/refind
    src_refind = "/usr/share/refind"
    if not os.path.exists(src_refind):
        # Trying chroot path as fallback if live env is different
        src_refind = os.path.join(MOUNT_POINT, "usr/share/refind")
        
    if not os.path.exists(src_refind):
        raise Exception(f"Could not locate rEFInd source files at {src_refind}!")

    mgr.log(f"Found rEFInd source: {src_refind}")

    # Destinations
    efi_dir = os.path.join(MOUNT_POINT, "boot/efi/EFI")
    dest_refind = os.path.join(efi_dir, "refind")
    dest_boot = os.path.join(efi_dir, "BOOT")
    
    # 1. Install to EFI/refind
    mgr.log(f"Installing to {dest_refind}...")
    if os.path.exists(dest_refind):
        shutil.rmtree(dest_refind)
    shutil.copytree(src_refind, dest_refind)
    
    # 2. Copy binary to correct name if needed
    # rEFInd package usually has refind_x64.efi
    bin_path = os.path.join(dest_refind, "refind_x64.efi")
    if not os.path.exists(bin_path):
        mgr.log("Warning: refind_x64.efi not found in dest!")
        
    # 3. Setup Fallback (EFI/BOOT/bootx64.efi)
    mgr.log(f"Setting up fallback boot at {dest_boot}...")
    if os.path.exists(dest_boot):
        shutil.rmtree(dest_boot)
    shutil.copytree(dest_refind, dest_boot)
    
    # Rename for fallback
    fallback_bin = os.path.join(dest_boot, "bootx64.efi")
    start_bin = os.path.join(dest_boot, "refind_x64.efi")
    if os.path.exists(start_bin):
        shutil.move(start_bin, fallback_bin)
    else:
        mgr.log("Warning: Could not create bootx64.efi (source missing)")
        
    # 4. Copy icons/drivers/config if they are in subdirs of share
    # Usually /usr/share/refind contains: refind_x64.efi, refind.conf-sample, icons/, drivers_x64/
    # We copied the whole tree, so it should be there.
    # Just need to rename sample config
    
    for d in [dest_refind, dest_boot]:
        conf_sample = os.path.join(d, "refind.conf-sample")
        conf_target = os.path.join(d, "refind.conf")
        if os.path.exists(conf_sample) and not os.path.exists(conf_target):
            shutil.copy(conf_sample, conf_target)
            mgr.log(f"Created refind.conf in {os.path.basename(d)}")

    # 5. Attempt efibootmgr (Optional)
    mgr.log("Registering NVRAM entry (efibootmgr)...")
    try:
        # Determine disk and partition
        # Context has 'disk' e.g. /dev/sda
        disk = mgr.context.get('disk', '/dev/sda')
        # We assume partition 1 for EFI based on s_partition logic
        part_num = 1 
        
        # efibootmgr -c -d /dev/sda -p 1 -L "KDOS" -l "\EFI\refind\refind_x64.efi"
        cmd = [
            'efibootmgr', '-c',
            '-d', disk,
            '-p', str(part_num),
            '-L', 'KDOS',
            '-l', '\\EFI\\refind\\refind_x64.efi'
        ]
        mgr.run_cmd(cmd)
    except Exception as e:
        mgr.log(f"Warning: efibootmgr failed: {e}. System should still boot via fallback.")

def s_finish(mgr, step):
    mgr.alert("Installation Complete!\nLog saved to /var/log/install.log\nYou can now reboot.")
    if mgr.ask_confirm("Reboot now?"):
        curses.endwin()
        os.system("reboot")
    else:
        sys.exit(0)

# --- Main ---

def main(stdscr):
    q = queue.Queue()
    mgr = InstallerManager(q)
    
    # Define Steps
    mgr.add_step("Welcome", s_welcome)
    mgr.add_step("Select Disk", s_select_disk)
    mgr.add_step("Partition Disk", s_partition)
    mgr.add_step("Format Partitions", s_format)
    mgr.add_step("Mount Filesystems", s_mount)
    mgr.add_step("Install Base System", s_install_base)
    mgr.add_step("Configure System", s_configure)
    mgr.add_step("Install Bootloader", s_bootloader)
    mgr.add_step("Finish", s_finish)
    
    tui = TUI(stdscr, mgr, q)
    
    mgr.start()
    tui.loop()

if __name__ == "__main__":
    try:
        # Check root
        if os.geteuid() != 0:
            print("Error: Must run as root")
            sys.exit(1)
        curses.wrapper(main)
    except KeyboardInterrupt:
        sys.exit(1)
